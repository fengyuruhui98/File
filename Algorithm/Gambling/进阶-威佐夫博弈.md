# 博弈论之威佐夫博弈
威佐夫博弈（Wythoff game）：  
有两堆各若干个物品，两个人轮流从任一堆取至少一个或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。  

这种情况下是颇为复杂的。我们用$（a[k]，b[k]）（a[k] ≤ b[k] ,k=0，1，2，…,n)$表示两堆物品的数量并称其为局势，如果甲面对$（0，0）$，那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：$(0, 0) (1, 2) (3, 5) (4, 7) (6, 10) (8, 13) (9, 15) (11, 18) (12, 20)$。（注：k表示奇异局势的序号， 第一个奇异局势k=0）  
可以看出,$a[0]=b[0]=0,a[k]$是未在前面出现过的最小自然数,而 $b[k]= a[k] + k$。


奇异局势的性质：

任何自然数都包含在一个且仅有一个奇异局势中。  
由于a[k]是未在前面出现过的最小自然数，所以有a[k] > a[k-1] ，以及b[k]> a[k]  
而 b[k]= a[k] + k > a[k-1] + k > a[k-1] + k - 1 = b[k-1] > a[k-1] 。所以性质1成立。  
任意操作都可将奇异局势变为非奇异局势。  
事实上，若只改变奇异局势（a[k]，b[k]）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（a[k]，b[k]）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。  
采用适当的方法，可以将非奇异局势变为奇异局势。  
假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；  
如果 a = a[k] ，b > b[k] 那么，取走b - b[k]个物体，即变为奇异局势；  
如果 a = a[k] ，b < b[k] 则同时从两堆中拿走a-a[b-a]（注：这里b-a是a的下标， 不是a*(b-a)）个物体变为奇异局势（ a[b-a], b-(a-a[b-a])）→（ a[b-a], a[b-a]+ b-a）；  
如果 a > a[k] ，b= a[k] + k 则从第一堆中拿走多余的数量a - a[k] 即可；  
如果a < a[k] ，b= b[k],分两种情况，第一种，a=a[n] （n< k）从第二堆里面拿走 b - b[n] 即可；第二种，a=b[n] （n < k）从第二堆里面拿走 b - a[n] 即可。  
结论：   
如果两个人都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。  
那么任给一个局势(a，b)，怎样判断它是不是奇异局势呢？我们有如下公式：  
a(k) = [k*(1+√5)/2]，b(k) = a(k) + k （其中k=0,1,2…n表示下标 ，[ ]括号框住部分表示取整)  
对于给出的局势(a,b)，首先通过 b(k)-a(k) 得到k值，即k=b-a。然后通过公式[k*(1+√5)/2]（[ ]括号表示取整）得到新的a’，若a’==a则表示该局势是奇异局势，否则不是  
奇妙的是其中出现了黄金分割数 (1+√5)/2 = 1.618…因此，由a(k)，b(k)组成的矩形近似为黄金矩形  


## 入门-1

[HDU1527 取石子游戏](http://acm.hdu.edu.cn/showproblem.php?pid=1527)  
问题描述  
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。  

输入数据  
输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。

输出数据  
输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。

样例输入  
2 1  
8 4  
4 7

样例输出  
0  
1  
0


分析：本题的考点其实就是威佐夫博弈，其仅仅是换了一个背景和说法  
因此我们可以直接根据前面对威佐夫博弈的分析写出如下代码：
```c
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
	int n,m;
	float eqa=(1+sqrt(5))/2;
	while(cin>>n>>m){
		if(n>m){
			int temp=n;
			n=m;m=temp;
		}
		int k=m-n;
		if(int(k*eqa)==n) cout<<"0"<<endl;
		else cout<<"1"<<endl;
	}
	return 0;
}
```

## 进阶-1

[HDU2177 取(2堆)石子游戏](http://acm.hdu.edu.cn/showproblem.php?pid=2177)  
问题描述  
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。如果你胜，你第1次怎样取?
  
输入数据  
输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000，且a<=b。a=b=0退出。

输出数据  
输出也有若干行，如果最后你是败者，则为0，反之，输出1，并输出使你胜的你第1次取石子后剩下的两堆石子的数量x,y,x<=y。如果在任意的一堆中取走石子能胜，同时在两堆中同时取走相同数量的石子也能胜，先输出取走相同数量的石子的情况。

样例输入  
1 2  
5 8  
4 7  
2 2  
0 0

样例输出  
0  
1  
4 7  
3 5  
0  
1  
0 0  
1 2  


分析：  
其实这道题的描述和前面的HDU1527差不多，不同的是这道题的要求略微麻烦些  
我们在判断了先手能够赢得比赛后，还需要输出先手在第一次用某种方法拿取石子后剩余的情况  
显然，有时候先手第一次能够拿取的方案有可能是有多种的
比如说对于初始局势(5,8)，先手为了取胜有两种取法：
1.在两堆中各取1颗石子，使局势变为(4,7)，显然这个局势是一个奇异局势，故后手必败  
2.在第二堆石子(8颗)中取走5颗石子，使局势变为(3,5)，显然这个局势也是一个奇异局势，故后手必败  
而当取法有多种的时候，我们又需要按题意对这些取法进行一个先后的排列  
题目的要求是“如果在任意的一堆中取走石子能胜，同时在两堆中各取相同数量的石子也能胜，先输出取走相同数量的石子的情况”

解答本题的难点就在这个顺序上  
我们这样想，由于题目所给的数据范围并不大，那么我们可以在判断了某个局势为非奇异局势后，对这个局势进行一个枚举，枚举分为两次，这两次的先后顺序也就逻辑表达了题目所要求的顺序：  
1.从两堆石子中同时取出相同数量的石子  
2.从多的那一堆中取石子（for遍历枚举）  
对于上面的每次取石子，我们都需要对当前剩余的石子局势进行判断，如果该局势是奇异局势就说明这种取法可取，直接输出；否则不可取  

在2中之所以要从多的那一堆里取值，是因为在威佐夫博弈中，我们要使某个初始局势（非奇异）变为奇异局势，那就需要找到合适的取法（这一点在前面威佐夫博弈的性质中提到过）。而若只对某个局势(a,b)进行分析（假设a < b），如果你取a作为枚举的界限，那么你的枚举结果就会有丢失，而你选b作为界限则不会。要知道，当你的枚举以b作为取值范围[1,b]时，那么当你的b小到某个值的时候，就相当于a,b就发生了交换。可是你若以[1,a]作为取值范围则不会，因此出现了枚举的情况丢失  

下面直接给出本题的完整代码：
```c
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
	int a,b,n,m,temp;
	float gsi=(1+sqrt(5))/2;
	while(cin>>a>>b)
	{
		if(a==0 && b==0) break;
		if(a>b){
			temp=a;
			a=b;b=temp;
		}
		int k=b-a;
		if(int(k*gsi)==a) cout<<"0"<<endl;
		else{
			cout<<"1"<<endl;
			for(int i=1;i<=a;i++)
			{
				n=a-i,m=b-i;
				if(int(k*gsi)==n){
					cout<<n<<" "<<m<<endl;
				}
			}
			for(int i=b;i>=0;i--)
			{
				n=a,m=i;
				if(n>m){
					temp=n;
					n=m;m=temp;
				}
				k=m-n;
				if(int(k*gsi)==n){
					cout<<n<<" "<<m<<endl;
				}
			}
		}
	}
	return 0;
}
```