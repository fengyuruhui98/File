## 1.DFS
深度优先遍历得到的是图的一个连通分量。

算法流程：

- 从某个结点 v 出发，访问结点 v，并令 vis[v] = 1；
- 查找 v 的所有邻接点 i，若结点 i 并未被访问过（vis[i] = 0），则从结点 i 出发，深度优先遍历图，转至步骤（1）。
- 递归结束后，遍历 vis 数组，若数组中有一个值不为 1，则说明该点未被访问，图不连通。
- 
## 2.BFS
算法流程：

- 从某个结点 v 出发，将结点 v 放入队列 q 中；
- 队列不空时，弹出队首结点 v；
    - 如果结点 v 没被访问过，查找 v 的所有邻接点 i；
        - 如果结点 i 没被访问过，放入队列 q 中；
        - 如果结点 i 已被访问，跳过。
    - 如果结点 v 已被访问，跳过。
    - 标记结点 v 已被访问（容易遗漏！！！）。
- 队列为空时，遍历 vis 数组，若数组中有一个值不为 1，则说明该点未被访问，图不连通。
## 3.并查集
并查集可以简单理解为找根结点，使用 father 数组记录每个结点的根节点。

算法流程：

- 初始化每个结点的根节点为结点本身；（可使用 iota() 函数）
- 从某个结点 v 开始，查找 v 的所有邻接点 i，如果结点 v 和结点 i 的根节点不同（father[v] != father[i]），则把两个结点的根节点设为下标较小的根节点（father[v] = father[i] = min(father[v], father[i])）。
- 循环结束时，遍历 father 数组，若数组中有一个值不为 0，则说明该点的根节点并不是 0 号结点，图不连通。

## 4.比较
- DFS 和 BFS 都是记录结点是否已访问，而并查集是记录每个结点的根节点。
- 三种算法都需要查询当前结点的所有邻接点，因而建议以邻接表的形式存储图。
- 三种算法的时间复杂度和空间复杂度如下表所示，其中 E 为边的数目，V 为结点的数目。

|时间复杂度|空间复杂度
-|-|-
DFS|O(E)|O(V)
BFS|O(E)|O(V)
UF|O(E)|O(V)