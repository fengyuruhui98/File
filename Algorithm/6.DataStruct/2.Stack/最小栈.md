设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

- push(x) —— 将元素 x 推入栈中。
- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。
示例:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

## 1. 辅助栈（空间复杂度O(n),时间复杂度O(1)）
每次进行两个入栈操作，第一个栈正常入，第二个栈存储当前数据入栈后整个栈内最小元素，在第二个栈顶即为当前所有数据中最小元素。
两个栈长度大小保持一致。
```c
typedef struct {
    int *arr;
    int top;
    int size;//xieshangzaishuo
    int min_num;
    int *brr;
} MinStack;


MinStack* minStackCreate() {
    MinStack* m = (MinStack *)malloc(sizeof(MinStack)*1);
    m->arr = (int *)malloc(sizeof(int)*101000);
    m->brr = (int *)malloc(sizeof(int)*101000);
    m->top = -1;
    m->size = 0;
    m->min_num = 2147483647;
    return m;
}

void minStackPush(MinStack* obj, int val) {
    obj->arr[++(obj->top)] = val;
    (obj->size)++;
    if(val < (obj->min_num))
    {
        obj->min_num = val;
        // obj->brr[(obj->top)] = obj->min_num;
    }
    obj->brr[(obj->top)] = obj->min_num;
    // else
        // obj->brr[(obj->top)] = 
}

int minStackTop(MinStack* obj) {
    return obj->arr[(obj->top)];
}

void minStackPop(MinStack* obj) {
    (obj->size)-= 1;
    (obj->top)--;
    // 最小的弹出去之后 记得更新 min_num
    if(obj->size == 0)
        obj->min_num = 2147483647;
    else
        obj->min_num = obj->brr[(obj->top)];
}

int minStackGetMin(MinStack* obj) {
    return obj->brr[obj->top];
}

void minStackFree(MinStack* obj) {
    free(obj->arr);
    free(obj->brr);
    obj->size = 0;
    obj->top = -1;
    obj->min_num = 0;
}
```
## 2. 差分（空间复杂度O(1),时间复杂度O(1)）
- 第一次push的时候，把该元素作为最小元素min。
- 在后面的push操作中，首先判断当前元素num是否小于min,如果不小于min，就向栈中存入元素值data = num-min(这个值肯定大于0，因为num大于min)；如果num小于min，也向栈中存入data = num-min(data小于0)，同时记得更新min值。
- pop的时候，首先判断栈顶的元素data是否大于0，如果大于0，则pop的值应该是num=data +min（因为存的时候是data = num-min);如果小于0，则pop的时候应该是min，同时要更新min，min = min- data。
同时get_min时直接返回min的值就是整个栈元素中的最小值

```c
typedef struct {
    int *arr;
    int top;
    int size;//xieshangzaishuo
    int min_num;
} MinStack;


MinStack* minStackCreate() {
    MinStack* m = (MinStack *)malloc(sizeof(MinStack)*1);
    m->arr = (int *)malloc(sizeof(int)*101000);
    m->top = -1;
    m->size = 0;
    m->min_num = 2147483647;
    return m;
}

void minStackPush(MinStack* obj, int val) {
    obj->arr[++(obj->top)] = val - (obj->min_num);
    (obj->size)++;
    obj->min_num = (val > obj->min_num ? obj->min_num : val);
}

int minStackTop(MinStack* obj) {
    return (obj->arr[(obj->top)] > 0 ? obj->min_num + obj->arr[(obj->top)] : obj->min_num);
}

void minStackPop(MinStack* obj) {
    (obj->size)-= 1;
    (obj->top)--;
    // 最小的弹出去之后 记得更新 min_num
    if(obj->size == 0)
        obj->min_num = 2147483647;
    else if(obj->arr[obj->top] > 0){
      return obj->arr[obj->top] + obj->min_num;
    }else{
      int ans = obj->min_num;
      obj->min_num = obj->min_num - obj->arr[obj->top];
      return ans;
    }
}

int minStackGetMin(MinStack* obj) {
    return obj->min_num;
}

void minStackFree(MinStack* obj) {
    free(obj->arr);
    obj->size = 0;
    obj->top = -1;
    obj->min_num = 0;
}
```