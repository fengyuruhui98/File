# 6.4图的应用
最小生成（代价）树、最短路径、拓扑排序、关键路径
## 6.4.1最小生成树  
**一个连通图的最小生成树包含图的所有顶点，并且只含尽可能少的边。** 对于生成树来说，若砍去其一条边，则会使生成树变为非连通图；若给他增加一条边，则会形成图中的一条回路。  
对于带权连通无向图`G = (V, E)`，生成树不同，每棵树的权（即树上所有边上的权值之和）可能也不同。设`R`为`G`的所有生成树的集合，**若`T`为`R`中边的权值之和最小的那棵生成树，则`T`称为`G`的最小生成树（Minimum-Spanning-Tree, MST）。**  
最小生成树性质：  
1. 最小生成树是唯一的，树形并不唯一，`R`中可能有多个最小生成树。当图`G`中各边权值互不相等时，`G`的最小生成树唯一；若无向连通图`G`的边数比顶点数多1，即`G`是一棵树时，则其最小生成树就是其本身。  
2. 最小生成树边的权值总和是唯一的，虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，且是最小的。  
3. 最小生成树的边数为顶点数减一。  

构造最小生成树有多种算法，但都利用了如下性质：**假设`G = (V, E)`是一个带权无向连通图，`U`是顶点集`V`的一个非空子集。若`(u, v)`是一条具有最小权值的边，其中`u`属于`U`，`v`属于`V - U`，则必存在一棵包含边`(u, v)`的最小生成树。  
基于该性质的算法主要有`Prim算法`和`Kruskal算法`，都基于贪心策略。  
通用最小树生成算法：
```c
GENERIC_MST(G){
    T = NULL;
    while T 未形成一棵生成树；
        do 找到最小一条代价边（u, v）并且加入T后不会生成回路。
            T = T并（u，v）
}
```
### 1.Prim算法  
执行非常类似Dijkstra算法。生成过程如图：  
![图1][image1]  
初始时