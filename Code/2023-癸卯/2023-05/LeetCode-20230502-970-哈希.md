# LeetCode-970. 强整数
2023.05.02  
难度：中等    
给定三个整数 x 、 y 和 bound ，返回 值小于或等于 bound 的所有 强整数 组成的列表 。

如果某一整数可以表示为 xi + yj ，其中整数 i >= 0 且 j >= 0，那么我们认为该整数是一个 强整数 。

你可以按 任何顺序 返回答案。在你的回答中，每个值 最多 出现一次。 

>示例 1：  
输入：x = 2, y = 3, bound = 10
输出：[2,3,4,5,7,9,10]
解释： 
2 = 2^0 + 3^0
3 = 2^1 + 3^0
4 = 2^0 + 3^1
5 = 2^1 + 3^1
7 = 2^2 + 3^1
9 = 2^3 + 3^0
10 = 2^0 + 3^2


>示例 2：
输入：x = 3, y = 5, bound = 15
输出：[2,4,6,8,10,14]
 

>提示：  
1 <= x, y <= 100
0 <= bound <= 10^6

# 解

## 枚举-哈希表
```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int getbig(int a, int bound){
    int ret = 0, temp = a;
    if(a == 1) return 2;
    while(temp < bound){
        ret++;
        temp *= a;
    }
    return ret;
}

int* powerfulIntegers(int x, int y, int bound, int* returnSize){
    int a = getbig(x, bound), b = getbig(y, bound), length = 0;
    int * A = (int *)malloc(sizeof(int) * (a + 2)), * B = (int *)malloc(sizeof(int) * (b + 2)), * ans = (int *)malloc(sizeof(int) * bound), * hash = (int *)malloc(sizeof(int) * (bound + 1)); 
    memset(hash, 0x00, sizeof(int) * bound);

    A[0] = 1, A[1] = x, B[0] = 1, B[1] = y;
    for(int i = 2; i <= a; i++)A[i] = A[i - 1] * x;
    for(int i = 2; i <= b; i++)B[i] = B[i - 1] * y;
    for(int i = 0; i <= a; i++)for(int j = 0; j <= b; j++)if(A[i] + B[j] <= bound)hash[A[i] + B[j]] = 1;
            
    for(int i = 0; i <= bound; i++)if(hash[i] == 1)ans[length++] = i;
    * returnSize = length;
    return ans;
}
```