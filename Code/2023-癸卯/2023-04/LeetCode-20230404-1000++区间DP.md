# LeetCode-1000. 合并石头的最低成本  
2023.04.04  
难度：困难    
有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。

每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。

找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。

>示例 1：  
输入：stones = [3,2,4,1], K = 2  
输出：20  
解释：  
从 [3, 2, 4, 1] 开始。  
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。  
合并 [4, 1]，成本为 5，剩下 [5, 5]。  
合并 [5, 5]，成本为 10，剩下 [10]。  
总成本 20，这是可能的最小值。

>示例 2：  
输入：stones = [3,2,4,1], K = 3  
输出：-1  
解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。  
 
>示例 3：  
输入：stones = [3,5,1,2,6], K = 3  
输出：25  
解释：  
从 [3, 5, 1, 2, 6] 开始。  
合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。  
合并 [3, 8, 6]，成本为 17，剩下 [17]。  
总成本 25，这是可能的最小值。

提示：
1 <= stones.length <= 30  
2 <= K <= 30  
1 <= stones[i] <= 100

# 官解

## 前言
本题给定 $n$ 堆石头，每次合并连续的 $k$ 堆，合并的成本是这 $k$ 堆石头的总数，问最终把所有石头合并为一堆的最低成本。

我们从最简单的情况入手，当 $k$ 等于 $2$ 时，每次选择相邻的两堆进行合并。在最后一次合并之前，$n$ 堆石头经过若干次合并变为两堆石头，假设 $[0, p]$ 合并为一堆，$[p + 1, n − 1]$ 合并为一堆，然后我们再将这两堆合并成新的一堆，这次操作的成本是 $n$ 堆石头的总数。

注意到，将 $[0, p]$ 合并为一堆以及将 $[p+1,n−1]$ 合并为一堆都是问题规模较小的子问题，可以递归求解。我们设 $d[l][r]$ 是 $[l,r]$ 合并为一堆石头的最低成本，然后用记忆化搜索或者递推的方式来求解。我们用初态、转移方程和目标来描述求解过程：

- 初态：对于所有的 $d[i][i]$，初始化为 $0$，其他状态初始值设置为正无穷。

- 转移方程： $d[l][r]=min{d[l][p]+d[p+1][r]}$，其中 $l≤p<r$。

- 目标：$d[0][n−1]$。

以上就是 $k=2$ 时的求解思路，在这种情况下，该题目为经典的区间动态规划问题。

## 方法一：动态规划
### **思路与算法**

接下来我们思考当 $k$ 为其他数字时如何求解。

$n$ 大于 $1$ 时若想将 $n$ 堆石子合并为 $1$ 堆，我们首先准备好不同的 $k$ 堆，因此可以用 $d[l][r][t]$ 描述这个状态，表示将 $[l,r]$ 合并为 $t (1≤t≤k)$ 堆的最低成本。与 $k=2$ 时的思考方式一致，我们考虑一个分界点 $p (l≤p<r)$，令 $[l,p]$ 合并为 $1$ 堆，再令 $[p+1,r]$ 合并为 $t−1$ 堆，这样就可以将问题拆分为两个子问题进行求解。

- 初态：对于所有的 $d[i][i][1]$，初始化为 $0$，其他状态设置为正无穷。

- 转移方程：
    - 当 $t=1$ 时，$d[l][r][t]=d[l][r][k]+sum[l][r]$，其中 $sum[l][r]$ 是本次合并的成本，区间内石头的总数。
    
    - 否则，$d[l][r][t]=min{d[l][p][1]+d[p+1][r][t−1]}$，其中 $l≤p<r$。

- 目标：$d[0][n−1][1]$。

>在转移过程中，我们只考虑了将 $[l,p]$ 合并为 $1$ 堆的子问题，倘若将 $d[l][r][t]$ 拆分为 $d[l][p][2]+d[p+1][r][t−2]$ 是否可行？答案是可行的，但是会重复求解。递归求解 $d[l][p][2]$ 时，我们会再枚举一个 $p_1 (l≤p_1<p)$ 来求解 $d[l][p_1][1]$ 。所以我们只需要考虑拆分左边区间 $[l,p]$ 合并为一堆的子问题即可，可以不重不漏的遍历所有子问题。  
为什么只考虑 $t≤k$ 的情况？因为我们在状态转移时不需要这样的子状态，如果 $t>k$ ，我们希望子问题能够把它合并到小于 $k$ 堆的状态。  
那么什么情况会无解？每一次合并将 $k$ 堆石头变为 $1$ 堆，堆数减少 $k−1$，如果合并若干次要使得 $n$ 堆变为 $1$ 堆，就需要 $n−1$ 是 $k−1$ 的倍数。只要满足这个条件，$d[0][n−1][k]$ 一定有解，否则无解。在求解过程中，一些中间状态也有可能无解，我们可以直接用正无穷这个数字来表征它无解。  
最后来看一下是否有优化点，在拆分子问题 $d[l][p][1]$ 时，我们提前知道了当 $p−l$ 是 $k−1$ 的倍数时才会有解，因此从 $l$ 开始枚举 $p$，每次递增 $k−1$。这样可以避免很多无解状态的枚举。

### **代码**

记忆化搜索代码如下

```C++
//c++
class Solution {
    static constexpr int inf = 0x3f3f3f3f;
    vector<vector<vector<int>>> d;
    vector<int> sum;
    int k;
public:
    int get(int l, int r, int t) {
        // 若 d[l][r][t] 不为 -1，表示已经在之前的递归被求解过，直接返回答案
        if (d[l][r][t] != -1) {
            return d[l][r][t];
        }
        // 当石头堆数小于 t 时，一定无解
        if (t > r - l + 1) {
            return inf;
        }
        if (t == 1) {
            int res = get(l, r, k);
            if (res == inf) {
                return d[l][r][t] = inf;
            }
            return d[l][r][t] = res + (sum[r] - (l == 0 ? 0 : sum[l - 1]));
        }
        int val = inf;
        for (int p = l; p < r; p += (k - 1)) {
            val = min(val, get(l, p, 1) + get(p + 1, r, t - 1));
        }
        return d[l][r][t] = val;
    }
    int mergeStones(vector<int>& stones, int k) {
        int n = stones.size();
        if ((n - 1) % (k - 1) != 0) {
            return -1;
        }
        this->k = k;
        d = vector(n, vector(n, vector<int>(k + 1, -1)));
        sum = vector<int>(n, 0);

        // 初始化
        for (int i = 0, s = 0; i < n; i++) {
            d[i][i][1] = 0;
            s += stones[i];
            sum[i] = s;
        }
        int res = get(0, n - 1, 1);
        return res;
    }
};
```

```c
//c
static int inf = 0x3f3f3f3f;
    
int min(int a, int b) {
    return a < b ? a : b;
}

int get(int l, int r, int t, int ***d, int *sum, int k) {
    // 若 d[l][r][t] 不为 -1，表示已经在之前的递归被求解过，直接返回答案
    if (d[l][r][t] != -1) {
        return d[l][r][t];
    }
    // 当石头堆数小于 t 时，一定无解
    if (t > r - l + 1) {
        return inf;
    }
    if (t == 1) {
        int res = get(l, r, k, d, sum, k);
        if (res == inf) {
            return d[l][r][t] = inf;
        }
        return d[l][r][t] = res + (sum[r] - (l == 0 ? 0 : sum[l - 1]));
    }
    int val = inf;
    for (int p = l; p < r; p += (k - 1)) {
        val = min(val, get(l, p, 1, d, sum, k) + get(p + 1, r, t - 1, d, sum, k));
    }
    return d[l][r][t] = val;
}

int mergeStones(int* stones, int stonesSize, int k) {
    int n = stonesSize;
    if ((n - 1) % (k - 1) != 0) {
        return -1;
    }
    int sum[n];
    int ***d = (int ***)malloc(sizeof(int **) * n);
    memset(sum, 0, sizeof(sum));
    for (int i = 0; i < n; i++) {
        d[i] = (int **)malloc(sizeof(int *) * n);
        for (int j = 0; j < n; j++) {
            d[i][j] = (int *)malloc(sizeof(int) * (k + 1));
            memset(d[i][j], 0xff, sizeof(int) * (k + 1));
        }
    }

    // 初始化
    for (int i = 0, s = 0; i < n; i++) {
        d[i][i][1] = 0;
        s += stones[i];
        sum[i] = s;
    }
    int res = get(0, n - 1, 1, d, sum, k);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            free(d[i][j]);
        }
        free(d[i]);
    }
    return res;
}
```

递推代码如下

```C++
//c++
class Solution {
    static constexpr int inf = 0x3f3f3f3f;
public:
    int mergeStones(vector<int>& stones, int k) {
        int n = stones.size();
        if ((n - 1) % (k - 1) != 0) {
            return -1;
        }

        vector d(n, vector(n, vector<int>(k + 1, inf)));
        vector<int> sum(n, 0);

        for (int i = 0, s = 0; i < n; i++) {
            d[i][i][1] = 0;
            s += stones[i];
            sum[i] = s;
        }

        for (int len = 2; len <= n; len++) {
            for (int l = 0; l < n && l + len - 1 < n; l++) {
                int r = l + len - 1;
                for (int t = 2; t <= k; t++) {
                    for (int p = l; p < r; p += k - 1) {
                        d[l][r][t] = min(d[l][r][t], d[l][p][1] + d[p + 1][r][t - 1]);
                    }
                }
                d[l][r][1] = min(d[l][r][1], d[l][r][k] + 
                                sum[r] - (l == 0 ? 0 : sum[l - 1]));
            }
        }
        return d[0][n - 1][1];
    }
};
```

```python
#python 3
class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:
        n = len(stones)
        if (n - 1) % (k - 1) != 0:
            return -1

        d = [[[inf] * (k + 1) for _ in range(n)] for _ in range(n)]
        sum = [0] * n
        s = 0
        for i in range(n):
            d[i][i][1] = 0
            s += stones[i]
            sum[i] = s

        for L in range(2, n + 1):
            for l in range(n - L + 1):
                r = l + L - 1
                for t in range(2, k + 1):
                    for p in range(l, r, k - 1):
                        d[l][r][t] = min(d[l][r][t], d[l][p][1] + d[p + 1][r][t - 1])
                d[l][r][1] = min(d[l][r][1], d[l][r][k] + (sum[r] - (0 if l == 0 else sum[l - 1])))
        return d[0][n - 1][1]
```

### **复杂度分析**

- 时间复杂度：$O(n^3k)$，其中 $n$ 是 $stones$ 的长度。
- 空间复杂度：$O(n^2k)$，其中 $n$ 是 $stones$ 的长度。

## 方法二：状态优化
在方法一中，我们用 $d[l][r][t]$ 表示将区间 $[l,r]$ 的石头堆合并为 $t$ 堆的最小成本，这里 $t$ 的范围是 $[1,k]$。事实上，对于一个固定的区间 $[l,r]$，最终合并到小于 $k$ 堆时的堆数是固定的。

我们每次合并都会减小 $k−1$ 堆，初始时 $[l,r]$ 的堆数是 $r−l+1$，合并到不能合并时的堆数为 $(r−l)mod(k−1)+1$。所以我们可以直接用 $d[l][r]$ 表示将区间 $[l,r]$ 合并到不能为止时的最小成本。它本质上是通过忽略方法一中一定无解的状态，加快求解。

- 初态：对于所有的 $d[i][i]$，初始化为 $0$ ，其他状态设置为正无穷。

- 转移方程：$d[l][r]=min{d[l][p]+d[p+1][r]}，其中 $l≤p<r$。如果 $(r−l)mod(k−1)=0$ 则还需加上 $sum[l][r]$。

- 目标：$d[0][n−1]$ 。

### **代码**

```C++
//c++
class Solution {
    static constexpr int inf = 0x3f3f3f3f;
public:
    int mergeStones(vector<int>& stones, int k) {
        int n = stones.size();
        if ((n - 1) % (k - 1) != 0) {
            return -1;
        }

        vector d(n, vector<int>(n, inf));
        vector<int> sum(n, 0);

        for (int i = 0, s = 0; i < n; i++) {
            d[i][i] = 0;
            s += stones[i];
            sum[i] = s;
        }

        for (int len = 2; len <= n; len++) {
            for (int l = 0; l < n && l + len - 1 < n; l++) {
                int r = l + len - 1;
                for (int p = l; p < r; p += k - 1) {
                    d[l][r] = min(d[l][r], d[l][p] + d[p + 1][r]);
                }
                if ((r - l) % (k - 1) == 0) {
                    d[l][r] += sum[r] - (l == 0 ? 0 : sum[l - 1]);
                }
            }
        }
        return d[0][n - 1];
    }
};
```

```c
//c
const int inf = 0x3f3f3f3f;

int min(int a, int b) {
    return a < b ? a : b;
}

int mergeStones(int* stones, int stonesSize, int k) {
    int n = stonesSize;
    if ((n - 1) % (k - 1) != 0) {
        return -1;
    }

    int d[n][n];
    int sum[n];
    memset(d, 0x3f, sizeof(d));
    memset(sum, 0, sizeof(sum));

    for (int i = 0, s = 0; i < n; i++) {
        d[i][i] = 0;
        s += stones[i];
        sum[i] = s;
    }

    for (int len = 2; len <= n; len++) {
        for (int l = 0; l < n && l + len - 1 < n; l++) {
            int r = l + len - 1;
            for (int p = l; p < r; p += k - 1) {
                d[l][r] = min(d[l][r], d[l][p] + d[p + 1][r]);
            }
            if ((r - l) % (k - 1) == 0) {
                d[l][r] += sum[r] - (l == 0 ? 0 : sum[l - 1]);
            }
        }
    }
    return d[0][n - 1];
}
```

```python
#python3
class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:
        n = len(stones)
        if (n - 1) % (k - 1) != 0:
            return -1

        d = [[inf] * n for _ in range(n)]
        sum = [0] * n
        s = 0
        for i in range(n):
            d[i][i] = 0
            s += stones[i]
            sum[i] = s

        for L in range(2, n + 1):
            for l in range(n - L + 1):
                r = l + L - 1
                for p in range(l, r, k - 1):
                    d[l][r] = min(d[l][r], d[l][p] + d[p + 1][r])
                if (r - l) % (k - 1) == 0:
                    d[l][r] += (sum[r] - (0 if l == 0 else sum[l - 1]))
        return d[0][n - 1]

```

### **复杂度分析**

- 时间复杂度：$O(n^3)$ ，其中 $n$ 是 $stones$ 的长度。

- 空间复杂度：$O(n^2)$，其中 $n$ 是 $stones$ 的长度。


# 心路历程题解

这道题看似复杂，其实提示是很充足。

1. “合并” 暗示了分解的思想，而且问题具有最优子结构。分解的手段无非是2种，要么分治，要么动态规划。再看一眼，子问题是重复的，那么普通的分治不适合，我们应该保存每个子问题的结果，也就是动态规划（或者分治+memo）。

2. "1 <= stones.length <= 30"。根据问题规模猜测复杂度。LeetCode 通常将复杂度控制在 10^8, 那么复杂度 O(2^N) 不符合要求，估计复杂度是 n^3, 或者 n^4。如果是 n^2 或者 n^2log(n) 一般题目会将问题规模限制在 500-1000。复杂度 n^3 的典型算法就是动态规划。

3. 有没有更好的办法，比如贪心来解决呢？想一想，如果每次都选最小的3堆石头合并，这样做不行。比如[7,5,6,8] 2 这种情况，先合成5,6看起来就不大好。排除贪心算法，我一般有2种思路：a.一次决策的结果是否会提高下一次决策的代价，b.如果在一次决策中，2种选择代价相同，是否可以任选其一而不影响最后的结果。在本题中，a 不符合。

4. "如果不可能，返回-1" 这说明这道题不是普通的动态规划，还具有特殊情况。根据经验，建立一个二维数组dp[n][n+1]记录一个区间内的结果，左闭右开。但是这个 dp 中有许多位置是非法的，这应该怎么办呢？一个直观的策略是，首先判断位置是合法还是非法，然后分别处理。接下来就到了思考递推公式的环节，这里不展开说明了。

```python
#python3
class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:
        inf = 50000
        n = len(stones)
        if (n - 1) % (k - 1):
            return -1
        pre_sum = [0] * (n + 1)
        for i in range(n):
            pre_sum[i + 1] = pre_sum[i] + stones[i] 
        dp = [[0] * (n + 1) for _ in range(n)]
        for i in range(n - 1, -1, -1):
            for j in range(i + 2, n + 1):
                r = (j - i - 1) % (k - 1) + 1
                dp[i][j] = inf
                if r == 1:
                    for p in range(i + 1, j):
                        dp[i][j] = min(dp[i][j], dp[i][p] + dp[p][j])
                    dp[i][j] += pre_sum[j] - pre_sum[i]
                else:
                    for p in range(i + 1, j):
                        if (p - i - 1) % (k - 1) + 1 >= r:
                            continue
                        dp[i][j] = min(dp[i][j], dp[i][p] + dp[p][j])
        return dp[0][n]
```

# 极简代码
```python
class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:
        if (len(stones)-1)%(k-1):return -1
        @cache
        def back(l,r,c):
            if r-l+1 < c:return 0
            if c == 1:return back(l,r,k)+sum(stones[l:r+1])
            return min(back(l,i,1)+back(i+1,r,c-1) for i in range(l,r-c+2,k-1))
        return back(0,len(stones)-1,k)
```