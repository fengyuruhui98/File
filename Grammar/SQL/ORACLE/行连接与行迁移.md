# 1 概述
1. 出现场景
   当一行的 '数据过长' 而不能存储在单个 '数据块' 中时，就可能出现两种情况: 
   行链接（Row Chaining） 或 行迁移（Row Migration）

2. 区别
   (1) 行链接：发生在 insert 阶段
   (2) 行迁移：发生在 update 阶段

3. 注意事项
   (1) 无论是 行迁移 还是 行连接，都会影响数据库的 '性能'
   (2) 在读取这样的数据时，Oracle 会扫描多个数据块，执行更多的 I/O

# 2 详解
## 2.1 行链接 row chaining
1. 产生原因
   (1) insert 导致记录行不足以在 block 中存放的时候，就会发生 '行链接'
   (2) 常见类型的数据: long、long row、lob
   
2. 多个 block 块
   (1) 将上述记录拆分为多个 block 中，并将其 '链接'（chain）起来
   
3. 预防行链接
   (1) 扩大 block 的大小          -- 默认 8 k

## 2.2 行迁移 row migrating
1. 产生原因
   (1) update 导致记录行长增加，block 的 '剩余空间' 不足以存放这条记录时，就会产生 '行迁移'
   
2. rowid 不变
   (1) 原 block 中会有一个 '指针' 指向该条记录新的 block 地址

3. 预防行迁移
   (1) 将 block 中的 pctfree 调高 -- 默认 10%
   (2) 扩大 block 的大小          -- 默认 8 k

# 3 扩展
## 3.1 迁移查询
```sql
select dt.table_name,
       dt.pct_free, -- 空闲空间%
       dt.pct_used, -- 可用空间% = 1 - 空闲空间%
       dt.num_rows,
       dt.chain_cnt -- 迁移总数 = 行链接 + 行迁移
  from dba_tables dt
 where dt.owner = 'SCOTT'
 order by dt.table_name;
```
## 3.2 pfctree 和 pctused
[Oracle pctfree 和 pctused 详解](https://blog.csdn.net/qq_34745941/article/details/119595978)
## 3.3 block
[Oracle 数据块详解（block）](https://blog.csdn.net/qq_34745941/article/details/109812782)
