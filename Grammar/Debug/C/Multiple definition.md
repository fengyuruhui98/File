# Multiple definition of 解决
## 首先，最关键的，不要把全局变量以及全局方法的定义放在头文件里！！！！
### （1）给每个头文件加上条件编译：
注：此方法不是解决上述问题的方法，只是解决multiple definition of的一个方法。  
当多个文件包含同一个头文件时，而头文件中没有加上条件编译，就会独立的解释,然后生成每个文件生成独立的标示符。在编译器连接时，就会将工程中所有的符号整合在一起，由于，文件中有重名变量，于是就出现了重复定义的错误。  
给每一个头文件加上条件编译，避免该文件被多次引用时被多次解释，这是个应该是习惯。这个方法会解决大部分低级问题。  
条件编译示例  
```C
#ifndef XA_NAME_H
#define XA_NAME_H
……
#endif
```
### （2）使用extern定义全局变量：
可以把所有的全局变量放入一个头文件 global.h (名字随意起，但要加条件编译)中，每一个变量前面加extern，声明一下这些变量将在其它文件中定义。 然后建立一个和头文件名字对应的.c or .cpp文件 如global.c。在里面声明所有的全局变量。  
例如：
> void(*Handl_Display)();    

然后，让涉及到全局变量的文件include ”global.h“。这样编译时，会先对global.c编译生成一个global.o ，然后再和其它文件的.o链接生成可执行文件。  
简单一点说，就是在变量前加extern，之后变量的声明放在.c中。  
### （3）使用Static修饰：
在变量前加static，声明成静止变量。  
这个方法虽然可以解决multiple definition的问题，但是却会引发其他问题。  
#### **问题如下：**  
三个文件,a.h,a.c,b.c;  
在a.c和b.c 都include了a.h。  
在b.c中调用a.c中的函数对a.h中的变量进行赋值，但事实上b.c中的变量仍没被赋值。  
#### **问题分析：**
static的含义是迫使那个变量只在某个文件可见。   
假定你在头文件定义static x;   
且这个头文件分别被a.c和b.c包含;  
实质是在a.c和b.c里会分别定义一个名字叫x的变量，两个x毫无关系。  
在a.c里修改x，他不会导致b.c里的x变化.  
