大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。

小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。

 

测试平台：64位 X86 Ubuntu

 

代码：
```c
#include<stdio.h>
 
int is_little_endian()
{
    union check
    {
        int i;
        char a;
    }u;
 
    u.a=0;
    u.i=1;
 
    return(u.a == 1);
}
 
union test
{
    int i;
    char a[2];
}*p,test;
 
 
void main()
{
    if(is_little_endian())
        printf("the system is liite endian.\n");
    else
        printf("the system is big endian.\n");
 
    p = &test;
    p->a[0] = 0x12;
    p->a[1] = 0x34;
 
    printf("p->i = %x\n", p->i);
}
```
结果：

baoli@ubuntu:~/c$ ./a.out

the system is liite endian.

p->i = 3412

 

注：

union所有成员的起始地址一致

union的成员数据由低地址往高地址增长，也就是说a[0]是低地址、a[1]是高地址。
