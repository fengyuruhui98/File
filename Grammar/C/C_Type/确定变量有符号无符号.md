ANSI C中的整型升级：

1）char，short int或者int型位段（bit-field），包括它们的有符号或无符号变型，

2）以及枚举类型，可以使用在需要int或unsigned int的表达式中，

3）如果int可以完整地表示源类型的所有值，那么该类型的值就转换为int，否则转换为unsigned int。

 

ANSI C中的寻常算术转换：

1）当执行算术运算时，操作数的类型如果不同，就会发生转换。

2）数据类型一般朝着浮点精度更高、长度更长的方向转换，

3）整型数如果转换为signed不会丢失信息，就转换为signed，否则就转换为unsigned。

4）这个称为值保留（value preserving）原则。

 

1. 代码：
```c
#include <stdio.h>
 
#define IS_UNSIGNED(a) (a >= 0 && ~a >= 0)
 
int main()
{
    signed int a;
    unsigned int b;
    signed char c;
    unsigned char d;
 
    printf("a=%d, b=%d\n", IS_UNSIGNED(a), IS_UNSIGNED(b));
    printf("c=%d, d=%d\n", IS_UNSIGNED(c), IS_UNSIGNED(d));
}
```

2. 运行

D:\baoli\Desktop

λ .\a.exe

a=0, b=1

c=0, d=0

 

 

3. 分析

1）对于int型变量，可以使用

2）对弈char或short型变量，不适用

无论原先是否有符号，在~a >= 0中，char和short都被转换成了signed int（整型升级），然后再进行取反。

同时，常数0被认为是int（即signed int）类型，所以一律被判为有符号数了。

 

 

4. 改进
```c
#define IS_UNSIGNED(a) ((a |= (0x1 << (sizeof(a)*8 - 1))) > 0 ? 1 : 0)
```
把变量的最高位置1，然后判断变量是否大于0。如果大于0，就是无符号数；否则就是有符号数。

 

5. 结果

D:\baoli\Desktop

λ .\a.exe

a=0, b=1

c=0, d=1
