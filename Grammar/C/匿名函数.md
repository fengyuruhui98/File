在C语言中可以通过宏定义的方式实现匿名函数,具体如下:
```c
#define lambda(return_type, function_body) \
({ \
      return_type $this function_body \
          $this; \
})
#define $ lambda
```
该定义利用了GCC对C语言的扩展(被一对花括号包起来的代码块能够返回一个值),该宏定义能够返回$this(函数指针),如果我们需要一个返回两整数的和的函数,那么我们还可以对该宏再做一次封装,如下:

```c
#define add2int(function_body) $(int, (int _a, int _b){function_body})
```
然后我们就可以像下面这样来使用该宏(求一个整型数组所有元素的和):

```c
int sum(int *arr, int length, int (*add)(int, int));
int main(int argc, char **argv)
{
    int arr[] = { [0 ... 9] = 1, [10 ... 89] = 2, [90 ... 99] = 3 };
    int ret = sum(arr, sizeof(arr)/sizeof(int), add2int(int c = _a + _b; return c;));
    //add2int返回一个求两个整数和的函数

    printf("sum of arr is %d\n", ret);
}
int sum(int *arr, int length, int (*add)(int, int))
{
    int sum = 0;
    for (int i=0; i < length; i++)
    {
        sum = add(sum, arr[i]);
    }
    return sum;
}
```
当然也可以直接使用lambda宏,注意function_body需要包含函数的返回类型及参数列表,将上面第6行代码替换为:
```c
int ret = sum(arr, sizeof(arr)/sizeof(int), $(int, (int _a, int _b){
    int c = _a + _b;
    return c;
});
```
当然这样的代码肯定是效率低下,而且多此一举,这里只是简单的举个例子

---------------------------------------------------------------------------------------
C++匿名函数
1.定义
所谓匿名函数，其实类似于python中的lambda函数，其实就是没有名字的函数。使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间

2.详解
C++中的匿名函数通常为[capture](parameters)->return-type{body}，当parameters为空的时候，()可以被省去，当body只有“return”或者返回为void，那么”->return-type“可以被省去，下面将将对其中的参数一一解释

- capture：
[]        //未定义变量.试图在Lambda内使用任何外部变量都是错误的.
[x, &y]   //x 按值捕获, y 按引用捕获.
[&]       //用到的任何外部变量都隐式按引用捕获
[=]       //用到的任何外部变量都隐式按值捕获
[&, x]    //x显式地按值捕获. 其它变量按引用捕获
[=, &z]   //z按引用捕获. 其它变量按值捕获
parameters：存储函数的参数
return-type：函数的返回值
body：函数体
3.举个例子
我们可以将匿名函数做函数指针使用
```c
#include<iostream>
void main()
{
	int Featurea = 7;
	int Featureb = 9;
	auto fun = [](size_t Featurea, size_t Featureb){return Featurea<Featureb ? Featurea : Featureb; };
	int i = fun(Featurea, Featureb);
	std::cout << i << std::endl;
}
```
对一些STL容器函数sort,find等，其最后的一个参数时函数指针，我们也可以使用匿名函数来完成
```c
#include<vector>
#include<algorithm>
#include<iostream>
 
void main()
{
	std::vector<int> a(5);
	a[0] = 3;
	a[1] = 4;
	a[2] = 5;
	a[3] = 6;
	a[4] = 7;
	std::for_each(std::begin(a), std::end(a), [](int Feature){std::cout << Feature << std::endl; });
}
```
我们可以直接调用函数指针
```c
#include<iostream>
template <class Callback>
int CollectFeatures(Callback CB)
{
	int count = 0;
	for (int i = 0; i < 10; i++)
	{
		if (CB(i))
		{
			count++;
		}
	}
	return count;
}
bool AddFeature(size_t Feature)
{
	return Feature % 2;
}
void main()
{
	
	int i = CollectFeatures([](size_t Feature) -> bool { return AddFeature(Feature); });
	std::cout << i << std::endl;
}
```