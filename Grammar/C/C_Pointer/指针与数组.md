1. 说明：

1）变量p本身的地址在编译时确定，它是不变的；变量p存的内容是一个地址，在运行时才能确定，它是变化的

2）数组arr的地址在编译时确定，它是不变的；数组arr存的内容是一个数据

3）指针变量p能以数组的方式访问；数组arr能以指针的形式访问

1.1 代码：
```c
#include <stdio.h>
 
 
int main(void)
{
    int i = 10;
    int *p = &i;
    int arr[5];
 
    p[0] = 1;
    *(arr+0) = 2;
 
    printf("&i = %p\n", &i);
    printf("p = %p, &p = %p\n", p, &p);
    printf("arr = %p, &arr = %p\n", arr, &arr);
    printf("p[0] = %d, *(arr+0) = %d\n", p[0], *(arr+0));
 
    return 0;
}
```
 

1.2 结果：

baoli@ubuntu:~/c$ ./a.out
&i = 0x7ffe9c0feb04
p = 0x7ffe9c0feb04, &p = 0x7ffe9c0feb08
arr = 0x7ffe9c0feb10, &arr = 0x7ffe9c0feb10
p[0] = 1, *(arr+0) = 2
 

2. 说明：

1）定义为数组时，不能声明为指针

2）定义为指针时，不能声明为数组

 

2.1 代码:
```c
#include <stdio.h>
 
int array[5];
extern int *array;
 
int *p;
extern int p[];
 
int main(void)
{
    return 0;
}
 
```
2.2 编译:

baoli@ubuntu:~/c$ gcc test.c -g
test.c:4:13: error: conflicting types for ‘array’
extern int *array;
             ^
test.c:3:5: note: previous declaration of ‘array’ was here
int array[5];
     ^
test.c:7:12: error: conflicting types for ‘p’
extern int p[];
            ^
test.c:6:6: note: previous declaration of ‘p’ was here
int *p;
      ^
