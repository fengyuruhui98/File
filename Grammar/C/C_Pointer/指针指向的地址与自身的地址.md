测试平台：64位 X86 Ubuntu

代码1：
```c
#include <stdio.h>
 
void main(void)
{
    int *p;
    int i = 10;
 
    p = &i;
 
    printf("&p = %p, p = %p, &i = %p, *p = %d\n", &p, p, &i, *p);
}
```

结果：

baoli@ubuntu:~/c$ ./a.out

&p = 0x7ffea482c6a8, p = 0x7ffea482c6a4, &i = 0x7ffea482c6a4, *p = 10

 

分析：

1）指针变量p本身也占有内存，在64位机器上为8字节，且内存地址同样可以通过&p取得。

2）p存的是某个变量的内存地址，也即指针p指向某内存。

代码2：
```c
#include <stdio.h>
 
void main(void)
{
    int *p;
    int a[] = {0,1,2,3,4};
    p = a;
 
    printf("&p = %p, p = %p, a = %p, &a[0] = %p, &a = %p, a[0] = %d\n", &p, p, a, &a[0], &a, a[0]);
}
```

结果：

baoli@ubuntu:~/c$ ./a.out

&p = 0x7ffcfb384178, p = 0x7ffcfb384180, a = 0x7ffcfb384180, &a[0] = 0x7ffcfb384180, &a = 0x7ffcfb384180, a[0] = 0

 

分析：

1）a=&a=&a[0]，a和&a[0]代表数组首元素的地址，&a代表数组的地址。

2）&a、a、&a[0]虽然是地址，但是其代表的内存上存的是数据

2）&p内存上存放的是内存地址，但P指向的内存地址存放的是数据

