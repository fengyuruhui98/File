# 一. 幂等性

所谓的幂等性，是分布式环境下的一个常见问题，一般是指我们在进行多次操作时，所得到的结果是一样的，即多次运算结果是一致的。

也就是说，用户对于同一操作，无论是发起一次请求还是多次请求，最终的执行结果是一致的，不会因为多次点击而产生副作用。

# 二. 常见幂等性操作

在我们进行代码实现时，常见的请求有如下几种，他们的幂等性如下：
- select查询天然幂等；
- delete删除也是幂等，删除同一个数据多次其效果一样;
- update直接更新某个值时，幂等；update更新累加操作的的结果，非幂等；
- insert操作会每次都新增一条，非幂等；

# 三. 什么情况下会产生重复提交(非幂等性)

以下几种情况会导致非幂等性的结果出现：
- 连续点击提交两次按钮；
- 点击刷新按钮；
- 使用浏览器后退按钮重复之前的操作，导致重复提交表单；使用浏览器历史记录重复提交表单；
- 浏览器重复地HTTP请求等。

# 四. 解决方案
我们在开发时，解决幂等性的常见方式有以下几种：

1. 前端js提交禁止按钮可以用一些js组件
2. 使用Post/Redirect/Get模式

在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按F5导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。

3. 借助数据库操作

insert唯一索引，保证插入的数据只有一条。另外也可以基于悲观锁或者乐观锁，先查询后判断，首先通过查询数据库是否存在数据，如果存在证明已经请求过了，直接拒绝该请求；如果没有存在，就证明是第一次进来，直接放行。

4. session机制(后台服务端)
在服务器端，生成一个唯一的标识符，将它存入session，同时将它写入表单的隐藏字段中，然后将表单页面发给浏览器，用户录入信息后点击提交。
另外在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，如果相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除，如果不相等即重复提交。

5. Redis token机制每次接口请求前先获取一个token，然后再下次请求的时候在请求的header体中加上这个token，后台进行验证。如果验证通过删除token，下次请求再次判断token是否相等，如果不相等即重复提交。

# 五. Redis token的代码实现

接下来我就把Redis token方式的实现代码列出，如下所示：package com.qfjy.project.meeting.util;
```sql
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * @ClassName RedisRepeatUtil
 * @Description TODO  Redis解决重复提交
 * @Author guoweixin
 * @Date 2022/4/19
 * @Version 1.0
 */
@Slf4j
@Component
public class RedisRepeatUtil {
    /**Redis中间件*/
    @Autowired
    private RedisTemplate<String,Object> redisTemplate;

    /**
     * 会议发布页面KEY
     */
    public static String MEETING_MEMETING_PUB_ADD_KEY="meeting:meetingPub:pageToken:";

    /**
     * 会议抢单页面（进行页面）KEY
     */
    public static String MEETING_MEETING_GRAB_ADD_KEY="meeting:meetingGrab:add:pageToken:";

    /**
     * TODO 进入页面 生成token
     * 1、命令是根据进入页面的名称+用户ID
     * 2、过期时间是30分钟（为了避免产生无效的内存数据浪费）
     * @param key  redis key
     * @return
     */
    public String generToken(String key){
        String uuid= UUID.randomUUID().toString();
        log.info("uuid:"+uuid);
        //为期设置过期时
        redisTemplate.opsForValue().set(key, uuid);
        redisTemplate.expire(key,30, TimeUnit.MINUTES);
        return uuid;
    }
    /**
     * TODO（解决重复提交）
     * 前端 token和后端redis token进行比较判断
     * @param tokenUUID
     * @return
     */
    public boolean  compareToken(String key,String tokenUUID){
        //删除key
        boolean flag=tokenUUID.equals((String) redisTemplate.opsForValue().get(key));
        redisTemplate.delete(key);

        return flag;
    }
}
```

以上代码用来生成保证幂等性的token，我们会发现代码并不复杂。现在你知道怎么保证幂等性了吗？评论区说说你的看法呗。