```c
#include<stdio.h>
 
typedef struct test
{
    int a;
    int b;
    int c;
} TEST;
 
TEST arr[]={
    {1,2,3},
    {4,5,6},
    {7,8,9}
};
 
void main(void)
{
    TEST *tmp;
    tmp = arr;
 
    printf("tmp: %d, %d, %d,%d, %d, %d,%d, %d, %d\n", tmp[0].a, tmp[0].b, tmp[0].c, tmp[1].a, tmp[1].b, tmp[1].c, tmp[2].a, tmp[2].b, tmp[2].c);
    printf("arr: %d, %d, %d,%d, %d, %d,%d, %d, %d\n", arr[0].a, arr[0].b, arr[0].c, arr[1].a, arr[1].b, arr[1].c, arr[2].a, arr[2].b, arr[2].c);
}
```

执行结果：

[baoliw@AONTFN07 ~]$ ./a.out

tmp: 1, 2, 3,4, 5, 6,7, 8, 9

arr: 1, 2, 3,4, 5, 6,7, 8, 9

 

结果分析：

1）数组名可以直接赋值给相同类型的指针变量

2）指针变量可以采用类似数组的用法，如：tmp[0].a

 

注：不能将数组名赋值给数组变量，如：

TEST jj[3];

jj = arr;

编译将产生错误： error: incompatible types when assigning to type ‘struct TEST[3]’ from type ‘struct TEST *’
